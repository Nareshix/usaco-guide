---
id: usaco-597
source: USACO Gold 2016 January
title: Angry Cows
author: Benjamin Qi, Ryan Chou, David Zhou
---

<Spoiler title="Hint 1">

For problems where we're asked to minimize/maximize some value, we can ask ourselves these questions:

- How does the "validity" of the answer change as we increase/decrease it?
- What conditions must be true of an optimal solution?

</Spoiler>

<Spoiler title="Answer to Hint 1">

Note that for the minimum power that we launch a cow with is monotonic, since there is a set point where smaller values of $R$ will stop working.

This implies a binary search on the power $R$.

</Spoiler>

<Spoiler title="Solution">

[Official Analysis (C++ and Java)](http://www.usaco.org/current/data/sol_angry_gold_jan16.html)

<Warning>

The second and third solutions in the analysis fail on the following test case:

```
2
0
1
```

The second one gives the wrong answer, and the third errors.

</Warning>

From the hints, we'll start binary searching on the initial power $R$. Now, we've reduced the problem into checking if a fixed power $R$ works for our set of haybales.

There are many ways to approach this (see the [Official Analysis](http://www.usaco.org/current/data/sol_angry_gold_jan16.html) for more information!), but perhaps the most straightforward way is running a second binary search on the maximum point we can place our cow.

This works because just like our power, there exists a set point where a cow being launched at a coordinate will not knock out all the haybales to the left/right. Since $N \leq 5 \cdot 10^4$, we can simulate these explosions naively.

## Implementation

**Time Complexity**: $\mathcal{O}(N \log^2 N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int MAX_POS = 1e9;

int main() {
	freopen("angry.in", "r", stdin);

	int n;
	cin >> n;
	vector<int> bales(n);
	for (int i = 0; i < n; i++) {
		cin >> bales[i];
		// to avoid floats, double all coordinates
		bales[i] *= 2;
	}
	sort(bales.begin(), bales.end());

	/**
	 * @returns whether it's possible to explode
	 * the rest of the haybales before/after idx
	 *
	 * @param pos position of our cow
	 * @param idx furthest haybale we hit with our radius
	 * @param r current radius at our position
	 * @param dir whether we're checking positions to the right/left
	 */
	function<bool(int, int, int, bool)> push = [&](int pos, int idx, int r, bool dir) {
		// finished search
		if (idx >= n - 1 && dir == 0) { return (idx >= n || pos + r >= bales[idx]); }
		if (idx <= 0 && dir == 1) { return (idx < 0 || pos - r <= bales[idx]); }

		if (dir == 0) {  // go right
			if (pos + r >= bales.back()) return true;

			int new_idx = idx;
			while (new_idx < n && pos + r >= bales[new_idx]) { new_idx++; }

			// no progression
			if (new_idx == idx) return false;

			return push(bales[new_idx - 1], new_idx, r - 2, dir);

		} else {  // go left
			if (pos - r <= bales[0]) return true;

			int new_idx = idx;
			while (new_idx < n && pos - r <= bales[new_idx]) { new_idx--; }

			// no progression
			if (new_idx == idx) return false;

			return push(bales[new_idx + 1], new_idx, r - 2, dir);
		}

		return false;
	};

	int lo = 0;
	int hi = MAX_POS * 2;
	while (lo < hi) {
		int power = lo + (hi - lo) / 2;

		/*
		 * finds the largest initial position such that
		 * our explosions propagate all the way to the left
		 */
		int pos_lo = 0;
		int pos_hi = MAX_POS * 2;

		while (pos_lo < pos_hi) {
			int pos = pos_lo + (pos_hi - pos_lo + 1) / 2;

			// get index of first haybale to our right
			int close = lower_bound(bales.begin(), bales.end(), pos) - bales.begin();

			// is it possible to complete our explosions heading left?
			if (close < n && push(pos, close, power, 1)) {
				pos_lo = pos;
			} else {
				pos_hi = pos - 1;
			}
		}

		int close = upper_bound(bales.begin(), bales.end(), pos_lo) - bales.begin();
		// is it possible to complete our explosions heading right?
		if (push(pos_lo, close, power, 0)) {
			hi = power;
		} else {
			lo = power + 1;
		}
	}

	freopen("angry.out", "w", stdout);
	// rescale our answer
	cout << fixed << setprecision(1) << (double)lo / 2 << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Angry {
	private static int n;
	private static int[] haybales;

	private static boolean valid(int pos, int idx, int power, int dir) {
		// exploded leftmost haybale
		if (idx <= 0 && dir == 0) { return (idx < 0 || pos - power <= haybales[idx]); }

		// exploded rightmost haybale
		if (idx >= n - 1 && dir == 1) {
			return idx >= n || pos + power >= haybales[idx];
		}

		if (dir == 0) {  // left
			if (pos - power <= haybales[0]) { return true; }

			// go as left as possible
			int next_idx = idx;
			while (next_idx >= 0 && pos - power <= haybales[next_idx]) { next_idx--; }

			// more movement is not possible
			if (next_idx == idx) { return false; }

			return valid(haybales[next_idx + 1], next_idx, power - 2, dir);
		} else {  // right
			if (pos + power >= haybales[n - 1]) { return true; }

			// go as right as possible
			int next_idx = idx;
			while (next_idx < n && haybales[next_idx] <= pos + power) { next_idx++; }

			// more movement is not possible
			if (next_idx == idx) { return false; }

			return valid(haybales[next_idx - 1], next_idx, power - 2, dir);
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader("angry.in"));

		n = Integer.parseInt(br.readLine());
		haybales = new int[n];
		for (int i = 0; i < n; i++) {
			// double each position to eliminate decimals
			haybales[i] = Integer.parseInt(br.readLine()) * 2;
		}
		br.close();

		Arrays.sort(haybales);
		int l = 0, r = 2000000000;
		while (l <= r) {
			int power = (r - l) / 2 + l;

			// find the rightmost haybale that can still reach the left
			int pos_l = 0, pos_r = 2000000000;
			while (pos_l <= pos_r) {
				int pos = (pos_r - pos_l) / 2 + pos_l;

				// index of candidate haybale
				int idx = Arrays.binarySearch(haybales, pos);
				if (idx < 0) { idx = -idx - 1; }

				// can we explode all haybales on left?
				if (idx < n && valid(pos, idx, power, 0)) {
					pos_l = pos + 1;
				} else {
					pos_r = pos - 1;
				}
			}

			int idx = Arrays.binarySearch(haybales, pos_l);
			if (idx < 0) {
				idx = -idx - 1;
			} else {
				while (idx < n && haybales[idx] == pos_l) { idx++; }
			}

			// can we explode all haybales on the right?
			if (valid(pos_l, idx, power, 1)) {
				r = power - 1;
			} else {
				l = power + 1;
			}
		}

		PrintWriter pw = new PrintWriter(new FileWriter("angry.out"));
		pw.printf("%.1f%n", (double)l / 2.0);
		pw.close();
	}
}
```

</JavaSection>
<PySection>

```py
import sys


def valid(mid: int) -> bool:
	# L to R
	i, j = 0, 0

	# maxpos finds the rightmost index that can reach the left
	maxpos = hay[0] + mid
	r = mid % 2
	while j < n and r <= mid:
		if hay[i] + r >= hay[j]:
			j += 1
		else:
			if j - i == 1:
				# recalculate radius needed between consecutive haybales
				r = (hay[j] - hay[i]) + (hay[j] - hay[i]) % 2
				if r >= mid:
					# update max possible position if radius is sufficient
					maxpos = min(maxpos, hay[i] + mid)
					break
			else:
				# increment radius if skipping multiple haybales
				r += 2
				i = j - 1
		if r <= mid:
			maxpos = max(maxpos, hay[i] + mid)

	# R to L
	i, j = n - 1, n - 1

	# minpos finds the leftmost index that can reach the right
	minpos = hay[-1] - mid
	r = mid % 2
	while j >= 0 and r <= mid:
		if hay[i] - r <= hay[j]:
			j -= 1
		else:
			if i - j == 1:
				# recalculate radius needed between consecutive haybales
				r = (hay[i] - hay[j]) + (hay[i] - hay[j]) % 2
				if r >= mid:
					# update min possible position if radius is sufficient
					minpos = min(minpos, hay[i] - mid)
					break
			else:
				# increment radius if skipping multiple haybales
				r += 2
				i = j + 1
		if r <= mid:
			minpos = min(minpos, hay[i] - mid)

	# explosion possible if ranges overlap
	return minpos <= maxpos


with open("angry.in", "r") as f:
	n = int(f.readline().strip())
	# double positions to avoid decimals
	hay = [int(f.readline()) * 2 for _ in range(n)]
hay.sort()

# binary search for lowest initial power
l, r = 0, hay[-1]
while l < r:
	mid = (l + r) // 2
	if valid(mid):
		r = mid
	else:
		l = mid + 1

# rescale final asnwer
print("{l / 2:.1f}", file=open("angry.out", "w"))
```

</PySection>
</LanguageSection>

</Spoiler>

---
id: usaco-1085
source: USACO Bronze 2021 January
title: Just Stalling
author: Ananth Kashyap, David Guo
---

[Official Analysis (C++ and Java)](http://www.usaco.org/current/data/sol_prob3_bronze_jan21.html)

## Solution 1

Let's consider the cows in descending order of height.

First, notice that the number of stalls we can place the tallest cow in is the number of stalls with height greater than or equal to the height of this cow.

Next, the number of stalls we can place the second tallest cow in is the number of stalls at least as tall as this cow, minus one, since the tallest cow already occupies one of these stalls. The key observation here is that this number is independent of which stall the tallest cow is placed in (which is why we sort the cows in descending order).

Similarly, the number of stalls the third tallest cow can be placed in is the number of stalls at least as tall as this cow, minus two, since the two tallest cows occupy two of these stalls.

This pattern continues, so we can compute the answer by simply multiplying all of these numbers (choices) together.

## Solution 1

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<int> cows(n);
	vector<int> stalls(n);
	for (int i = 0; i < n; i++) { cin >> cows[i]; }
	for (int i = 0; i < n; i++) { cin >> stalls[i]; }

	sort(cows.begin(), cows.end());
	sort(stalls.begin(), stalls.end());

	vector<long long> possible_places(n);
	// Create a list containing the number of stalls each cow can use
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (cows[i] <= stalls[j]) { possible_places[i]++; }
		}
	}

	long long possibilities = 1;
	/*
	 * For each cow, find out the number of stalls it can use in a valid permutation
	 * Use the formula provided in the explanation
	 * Multiply the cumulative product by this value
	 */
	for (int i = n - 1; i >= 0; i--) {
		possibilities *= possible_places[i] - (n - i - 1);
	}

	cout << possibilities << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class JustStalling {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());

		int[] cows = new int[n];
		int[] stalls = new int[n];

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { cows[i] = Integer.parseInt(st.nextToken()); }

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { stalls[i] = Integer.parseInt(st.nextToken()); }

		Arrays.sort(cows);
		Arrays.sort(stalls);

		long[] possiblePlaces = new long[n];
		// Create a list containing the number of stalls each cow can use
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (cows[i] <= stalls[j]) { possiblePlaces[i]++; }
			}
		}

		long possibilities = 1;
		/*
		 * For each cow, find out the number of stalls it can use in a valid permutation
		 * Use the formula provided in the explanation
		 * Multiply the cumulative product by this value
		 */
		for (int i = n - 1; i >= 0; i--) {
			possibilities *= possiblePlaces[i] - (n - i - 1);
		}

		System.out.println(possibilities);
	}
}
```

</JavaSection>
<PySection>

```py
n = int(input())
cows = sorted(map(int, input().split(" ")))
stalls = sorted(map(int, input().split(" ")))

possible_places = [0] * n
# Create a list containing the number of stalls each cow can use.
for i in range(n):
	for j in range(n):
		if cows[i] <= stalls[j]:
			possible_places[i] += 1

possibilities = 1
"""
For each cow, find out the number of stalls it can use in a valid permutation
Use the formula provided in the explanation
Multiply the cumulative product by this value
"""
for i in range(n - 1, -1, -1):
	possibilities *= possible_places[i] - (n - i - 1)

print(possibilities)
```

</PySection>
</LanguageSection>

## Solution 2

Instead of iterating through the stalls each time, we can use [two pointers](/silver/two-pointers).

## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;

	vector<int> cows(n);
	vector<int> stalls(n);
	for (int &c : cows) { cin >> c; }
	for (int &s : stalls) { cin >> s; }

	sort(cows.begin(), cows.end());
	sort(stalls.begin(), stalls.end());

	long long possibilities = 1;
	int j = n - 1;
	for (int i = n - 1; i >= 1; i--) {
		while (j >= 0 && stalls[j] >= cows[i]) { j--; }
		possibilities *= i - j;
	}

	cout << possibilities << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class JustStalling {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());

		int[] cows = new int[n];
		int[] stalls = new int[n];

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { cows[i] = Integer.parseInt(st.nextToken()); }

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { stalls[i] = Integer.parseInt(st.nextToken()); }

		Arrays.sort(cows);
		Arrays.sort(stalls);

		long possibilities = 1;
		int j = n - 1;
		for (int i = n - 1; i >= 1; i--) {
			while (j >= 0 && stalls[j] >= cows[i]) { j--; }
			possibilities *= (i - j);
		}

		System.out.println(possibilities);
	}
}
```
</JavaSection>
<PySection>

```py
n = int(input())

cows = list(map(int, input().split()))
stalls = list(map(int, input().split()))

cows.sort()
stalls.sort()

possibilities = 1
j = n - 1
for i in range(n - 1, 0, -1):
	while j >= 0 and stalls[j] >= cows[i]:
		j -= 1

	possibilities *= i - j

print(possibilities)
```

</PySection>
</LanguageSection>

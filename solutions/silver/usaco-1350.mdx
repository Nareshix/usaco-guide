---
id: usaco-1350
source: USACO Silver 2023 December
title: Bovine Acrobatics
author: Arnav Gokhale
---
[Official Editorial Link](https://usaco.org/current/data/sol_prob1_silver_dec23.html)

## Explanation

Notice that it is optimal to place the heaviest cows at the bottom and the lightest cows at the top, which makes the gap as large as possible. Therefore, we can sort the cows from heaviest to lightest. We maintain a sorted queue such that the top is the current heaviest cow. If a cow can't be added to the current heaviest tower, we know that it cannot be added to any tower, and thus that cow can be ignored.

However, this takes $\mathcal{O}(N \log N)$ operations for $N$ total cows, which is too slow. To optimize this, instead of considering cows individually, we can group them up by weight and count. Then, by maintaining a queue of cow groups sorted by weight, we can process all cows in $\mathcal{O}(N)$.

Additionally, each time we process the top group of the queue and add a new cow to that group, we can always add this new group back, since it will be lighter than all cows processed before it, since we sorted the cows from heaviest to lightest.

## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
	int n, m, k;
	cin >> n >> m >> k;
	vector<array<int, 2>> cowGroups(n);
	for (int i = 0; i < n; i++) {
		cin >> cowGroups[i][0] >> cowGroups[i][1];
		cowGroups[i][1] = min(cowGroups[i][1], m);
	}

	// Sorted list of cows
	sort(cowGroups.begin(), cowGroups.end());

	// Deque that stores the towers based on weight count pairs
	deque<array<int, 2>> towers;

	// Large value for original tower
	towers.push_back({-1000000000, m});

	int count = 0;
	for (int i = 0; i < n; i++) {
		int amt = cowGroups[i][1];

		// While there are still cows remaining in the current group and they can
		// still be placed onto the top of the queue, process
		while (!towers.empty() && towers[0][0] <= (cowGroups[i][0] - k) && amt > 0) {
			if (towers[0][1] > amt) {
				towers[0][1] -= amt;
				amt = 0;
				break;
			} else {
				amt -= towers[0][1];
				towers.pop_front();
			}
		}

		towers.push_back({cowGroups[i][0], cowGroups[i][1] - amt});
		count += cowGroups[i][1] - amt;
	}
	cout << count;
}
```

</CPPSection>
<PySection>

```py
from collections import deque

n, m, k = map(int, input().split())

pairs = []
for _ in range(n):
	w, a = map(int, input().split())
	pairs.append([w, a])
pairs.sort(reverse=True)
# Sort by descending weight

towers = deque()
# Queue that stores cows based on weight count pairs
towers.append([1e100, m])
# Use a large value for initial tower

answer = 0
for w, a in pairs:
	remaining = a
	# While there are still cows remaining in the current group and they can
	# still be placed onto the top of the queue, process
	while len(towers) > 0 and remaining > 0 and w + k <= towers[0][0]:
		if towers[0][1] > remaining:
			towers[0][1] -= remaining
			remaining = 0
		else:
			remaining -= towers[0][1]
			towers.popleft()
	count = a - remaining
	if count > 0:
		towers.append([w, count])
		answer += count

print(answer)
```

</PySection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Main {
	static class Group {
		final long weight;
		final long amount;

		Group(long weight, long amt) {
			this.weight = weight;
			this.amount = amt;
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(read.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());

		Group[] cowGroups = new Group[n];

		for (int i = 0; i < n; i++) {
			st = new StringTokenizer(read.readLine());
			long w = Integer.parseInt(st.nextToken());
			long a = Integer.parseInt(st.nextToken());
			cowGroups[i] = new Group(w, a);
		}

		Arrays.sort(cowGroups, Comparator.comparingLong(Group -> Group.weight));
		// Sort by decending weight

		// Queue that stores cows based on weight count pairs
		Deque<long[]> towers = new ArrayDeque<>();
		towers.addFirst(new long[] {(long)-1e18, m});
		// Use a large value for initial tower
		long answer = 0;

		for (Group p : cowGroups) {
			long w = p.weight;
			long a = p.amount;
			long remaining = a;
			// While there are still cows remaining in the current group and they can
			//  still be placed onto the top of the queue, process
			while (!towers.isEmpty() && remaining > 0 &&
			       w - k >= towers.peekFirst()[0]) {
				long[] top = towers.peekFirst();
				if (top[1] > remaining) {
					top[1] -= remaining;
					remaining = 0;
				} else {
					remaining -= top[1];
					towers.pollFirst();
				}
			}

			long cowsUsed = a - remaining;
			if (cowsUsed > 0) {
				towers.addLast(new long[] {w, cowsUsed});
				answer += cowsUsed;
			}
		}

		System.out.println(answer);
	}
}
```

</JavaSection>
</LanguageSection>

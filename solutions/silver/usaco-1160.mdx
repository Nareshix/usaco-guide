---
id: usaco-1160
source: USACO Silver 2021 December
title: Convoluted Intervals
author: Sachet Abeysinghe
---

[Official Analysis (C++, Java)](https://usaco.org/current/data/sol_prob3_silver_dec21.html)

## Explanation

Let's start with the brute force solution.

We could just iterate over all $k$ from $0â€¦2M$ along with all pairs of intervals $(a_i, b_i)$ and $(a_j, b_j)$.
For each combination, we increment our answer if $a_i + a_j \le k \le b_i + b_j$.
This runs in $\mathcal{O}(MN^{2})$, which is extremely slow.

Consider the two following optimizations:

### Optimization 1

Instead of considering each individual $k$, we can think of it as a pair of intervals contributing to all $k$ from $a_i + a_j$ to $b_i + b_j$.
To count this efficiently, we can use difference arrays, where we do range updates by incrementing position $a_i + a_j$ by one and decrementing position $b_i + b_j + 1$ by one.
This improves the time complexity to $\mathcal{O}(N^{2}+M)$.

### Optimization 2

We should probably take advantage of the fact that $M$ is relatively small.
Instead of looping through all pairs of intervals $(i, j)$ in $\mathcal{O}(N^2)$ time, we can iterate over all distinct $(a_i, a_j)$ and $(b_i, b_j)$ pairs in $\mathcal{O}(M^2)$.
We can then multiply the frequencies of $a_i$/$a_j$ and $b_i$/$b_j$ to get the number of ways we can pair them.

## Implementation

**Time Complexity:** $\mathcal{O}(N+M^{2})$

<LanguageSection>
<CPPSection>

```cpp
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public
class IntervalConvolution {

  public
	static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tokenizer = new StringTokenizer(in.readLine());
		int n = Integer.parseInt(tokenizer.nextToken());
		int m = Integer.parseInt(tokenizer.nextToken());
		long total_pairs = ((long)n) * ((long)n);
		long[] a_freq = new long[m + 1];
		long[] b_freq = new long[m + 1];
		for (int j = 1; j <= n; j++) {
			tokenizer = new StringTokenizer(in.readLine());
			int a = Integer.parseInt(tokenizer.nextToken());
			int b = Integer.parseInt(tokenizer.nextToken());
			a_freq[a]++;
			b_freq[b]++;
		}
		long[] a_sum_freq = new long[(2 * m) + 1];
		long[] b_sum_freq = new long[(2 * m) + 1];
		for (int x = 0; x <= m; x++) {
			for (int y = 0; y <= m; y++) {
				a_sum_freq[x + y] += a_freq[x] * a_freq[y];
				b_sum_freq[x + y] += b_freq[x] * b_freq[y];
			}
		}
		long a_valid = a_sum_freq[0];
		long b_valid = total_pairs;
		StringBuilder out = new StringBuilder();
		for (int x = 0; x <= 2 * m; x++) {
			if (x > 0) {
				a_valid += a_sum_freq[x];
				b_valid -= b_sum_freq[x - 1];
			}
			long res = a_valid + b_valid - total_pairs;
			out.append(res).append('\n');
		}
		System.out.print(out);
	}
}
```

</CPPSection>

</LanguageSection>
